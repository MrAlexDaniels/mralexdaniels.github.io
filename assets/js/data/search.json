[ { "title": "Creating APIM API using Azure Function Swagger/OpenApi", "url": "/posts/apim-swagger/", "categories": "Azure API Management, Azure Functions", "tags": "apim, azure api management, azure functions", "date": "2022-10-27 21:10:00 -0700", "snippet": "What are we trying to accomplish?When importing an API into APIM with swagger/OpenApi it helps to have everything as detailed as possible to eliminate manual changes after import. To do this we can decorate our swagger as much as possible, in this article we will cover how to use OpenApi decorators in Azure Functions.Lets look at the problemAs you can see in the image below, we are missing a few details that may be handy for a consumer of this API to know. The field name doesn’t have a description. Wouldn’t it be nice if you could put that into the swagger.json file instead of manually entering it within APIM? How do we mark a field as required?WalkthroughIf you have not already created an Azure Function project, I would recommend you do so to be able to walkthrough this as easy as possible.In this scenario we will be using Visual Studio and .NET FunctionsLet’s get started by creating a new Azure FunctionNot required but I would suggest creating one with OpenApi already configured. Click Add and we should see some generated code looking like the image below.[FunctionName(\"Function3\")][OpenApiOperation(operationId: \"Run\", tags: new[] { \"name\" })][OpenApiSecurity(\"function_key\", SecuritySchemeType.ApiKey, Name = \"code\", In = OpenApiSecurityLocationType.Query)][OpenApiParameter(name: \"name\", In = ParameterLocation.Query, Required = true, Type = typeof(string), Description = \"The **Name** parameter\")][OpenApiResponseWithBody(statusCode: HttpStatusCode.OK, contentType: \"text/plain\", bodyType: typeof(string), Description = \"The OK response\")]public async Task&lt;IActionResult&gt; Run( [HttpTrigger(AuthorizationLevel.Function, \"get\", \"post\", Route = null)] HttpRequest req){ _logger.LogInformation(\"C# HTTP trigger function processed a request.\"); string name = req.Query[\"name\"]; string requestBody = await new StreamReader(req.Body).ReadToEndAsync(); dynamic data = JsonConvert.DeserializeObject(requestBody); name = name ?? data?.name; string responseMessage = string.IsNullOrEmpty(name) ? \"This HTTP triggered function executed successfully. Pass a name in the query string or in the request body for a personalized response.\" : $\"Hello, {name}. This HTTP triggered function executed successfully.\"; return new OkObjectResult(responseMessage);}I am going to skip and configure this to look how I want my endpoint.[FunctionName(\"PostCharactersEndpoint\")][OpenApiOperation(operationId: \"POST Character\", tags: new[] { \"Character\" })][OpenApiRequestBody(\"application/json\", typeof(CharacterModel), Description = \"Creating a new Character\", Required = true)][OpenApiResponseWithBody(statusCode: HttpStatusCode.OK, contentType: \"text/plain\", bodyType: typeof(CharacterModel), Description = \"This is my description for 200 response documentation\")][OpenApiResponseWithBody(statusCode: HttpStatusCode.BadRequest, contentType: \"text/plain\", bodyType: typeof(ValidationResult), Description = \"ValidationError Response\")]public async Task&lt;IActionResult&gt; RunPost( [HttpTrigger(AuthorizationLevel.Function, \"post\", Route = \"character\")] HttpRequest req){ _logger.LogInformation(\"C# HTTP trigger function processed a request.\"); var body = await req.GetBodyAsync&lt;CharacterModel&gt;(); return new OkObjectResult(body.Value);}So whats going on here?We are naming the operationId to be anything but run. The reason being is we’ll have conflicts when deploying to APIM if every endpoint we create has the same name.[OpenApiRequestBody(\"application/json\", typeof(CharacterModel), Description = \"Creating a new Character\", Required = true)]We are telling swagger the request body for this POST is JSON and we are defining that body with CharacterModel (We will circle back to CharacterModel in a bit) and we have a basic descriptiontags: new[] { \"Character\" }` Tagging is a way for us to put these endpoints into categories that will be used within the APIM Developer Portal.[OpenApiResponseWithBody(statusCode: HttpStatusCode.OK, contentType: \"text/plain\", bodyType: typeof(CharacterModel), Description = \"This is my description for 200 response documentation\")]If the operation returns a 200 this is the model we expect back[OpenApiResponseWithBody(statusCode: HttpStatusCode.BadRequest, contentType: \"text/plain\", bodyType: typeof(ValidationResult), Description = \"ValidationError Response\")]If that status code is a bad request we are going to be returning ValidationResultsNow we have the tricky task of assigning descriptions to each field in our POST model and if that field should be required or not. From the example above we are expect CharacterModel to be the POST Body.Let’s take a look at that.public class CharacterModel{ [JsonRequired] [JsonProperty(PropertyName = \"name\")] public string Name { get; set; } = string.Empty; [JsonProperty(\"birth_year\")] public string BirthYear { get; set; } = string.Empty; [JsonProperty(\"eye_color\")] public string EyeColor { get; set; } = string.Empty; [JsonProperty(\"gender\")] public string Gender { get; set; } = string.Empty; [JsonProperty(\"hair_color\")] public string HairColor { get; set; } = string.Empty; [JsonProperty(\"height\")] public string Height { get; set; } = string.Empty; [JsonProperty(\"mass\")] public string Mass { get; set; } = string.Empty; [JsonProperty(\"skin_color\")] public string SkinColor { get; set; } = string.Empty;}The first this you might see is [JsonRequired], this is how to define in our swagger to say which fields are required and which ones are not. In order to create a description for our Name field we are going to need a little extra code. I’m also going to add a few more [JsonRequired].[JsonRequired][JsonProperty(PropertyName = \"name\")][OpenApiProperty(Description = \"This is the field description for the Name field in my model class\")]public string Name { get; set; } = string.Empty;Note – the namespace for this is going to be Microsoft.Azure.WebJobs.Extensions.OpenApi.Core.Attributes;Deploy the functions project and update APIM.To create/update APIM use the following Powershell commandaz apim api import --api-id {} --resource-group {} --service-name {} --path /starwars --specification-format OpenApi --specification-url foofoo.azurewebsites.net/api/swagger.jsonThe Result!Inside the Developer Portal you should see something that looks like the image below. The endpoint is now under the Character tag on the left side and directly under the endpoint name. name, birth_year, gender, hair_color are all marked as required fields. name now has a description to it." }, { "title": "Using Azure Active Directory For Custom Roles In APIM", "url": "/posts/apim-oauth2-custom-roles/", "categories": "Azure API Management, Advanced Policies, JWT Azure Active Directory", "tags": "apim, azure api management, active directory", "date": "2022-10-11 21:10:00 -0700", "snippet": "What are we trying to accomplish?When we want to limit what a consumer of an API can or cannot do we can accomplish this by creating custom roles in RBAC and issue them within our token. Once issued in our token we can read and apply these roles from within our APIM polcies.Use caseA user has access to consume API endpoints but we do not want them to be able to perform DELETE operations. By creating custom roles we are able to limit this access.WalkthroughIf you have not already created a backend app registration amd configured it with APIM please check out this resource to do so.Protect API’s using OAuth 2.0 in APIMApp RegistrationWithin the app registration created for our APIM enviroment we need to configure a few things.This is where we can create our custom roles that are assigned to each user. In this example we are creating roles that grant access to GET, POST, PATCH, PUT, DELETE, ADMINEnterprise ApplicationNow lets go into the Enterprise Application for our app. From here we can assign a role to a user/group. Add user/group Select user(s) or group(s) Select role AssignWe now have everything configured for the token to pass these roles!Getting/Viewing the tokenI found the easiest way to grab the issued token is to get it from the Developer Portal. From here we can use the Authorization to generate a Bearer Token that we can take a peek at. Copy the token and lets go to https://jwt.ms to take a look at it!Note: Remove “Bearer” from the token when pasting into https://jwt.msIf everything is configured correctly you should see the roles assigned to that user.Limiting Access with a PolicyWe have a couple important things going on here. First, we are validating the Bearer Token. Second we are outputting the token as a variable called jwt.&lt;validate-jwt header-name=\"Authorization\" failed-validation-httpcode=\"401\" failed-validation-error-message=\"Unauthorized. Access token is missing or invalid.\" output-token-variable-name=\"jwt\"&gt;Now that we have the token stored as a context variable we can access it. Using context.VariablesSo what are we doing? What does this line of code do?&lt;when condition=\"@(context.Request.Method == \"POST\" &amp;&amp; !((Jwt)context.Variables[\"jwt\"]).Claims[\"roles\"].Contains(\"api.post\"))\"&gt; &lt;return-response&gt; &lt;set-status code=\"403\" reason=\"Forbidden\" /&gt; &lt;/return-response&gt;&lt;/when&gt;We are looking at the Request.Method, if its a POST we need to check the token roles to determine if the user can perform that action.((Jwt)context.Variables[\"jwt\"]).Claims[\"roles\"].Contains(\"api.post\"))If the user does not have the correct role they will get a 403 Forbidden returns to them." }, { "title": "Policy Fragments In APIM", "url": "/posts/apim-policy-fragments/", "categories": "Azure API Management, Policies", "tags": "apim, azure api management", "date": "2022-09-19 21:10:00 -0700", "snippet": "In this article we are going to talk about policy fragments and use cases. Let’s start by understanding what a policy fragment is. Policy fragments help you configure policies consistently and maintain policy definitions without the need to repeat or retype XML code.ScenarioIn this policy we are looking at a JWT token and checking the roles that were included in the token. We are limiting the request methods they can perform. This policy is not going to be added to the All APIs level, but it must be applied to 3/7 of the APIs. Before the release of policy fragments, we would have had to duplicate this policy across all 3 APIs. When you have duplicate policies we must ensure any changes take place in all the duplicated area, leaving room for error and inconsistency. To fix this we can use a policy fragment! One policy that can be reused across multiple APIs.Creating a Policy FragmentWe are going to name the fragment and drop the policy from the image above into it.After the creation of it we can use the fragment anywhere we need it. Allowing for us to edit in one location instead of multiple.&lt;include-fragment fragment-id=\"request-jwt-roles\" /&gt;Limitations A policy fragment can’t include a policy section identifier (&lt;inbound&gt;, &lt;outbound&gt;, etc.) or the &lt;base/&gt; element. Currently, a policy fragment can’t nest another policy fragment.Reference Reuse policy configurations in your API Management policy definitions" } ]
